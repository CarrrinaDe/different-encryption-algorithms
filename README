Deaconu Andreea-Carina, 324CC

MAIN

	La task-urile unde trebuia sa delimitez encoded string de key (sa gasesc adresa de unde incepe key), mai exact task-urile 1, 3 si 6, am preluat ideea existenta in scheletul propus in arhiva temei, la task-ul 6: 
	Am aflat lungimea lui encoded string apeland functia strlen din C. Apoi, pornind de la adresa lui encoded string, m-am deplasat atat cat este lungimea sa, plus unu, ajungand la adresa de unde incepe key.

	In continuare, am apelat functia respectiva task-ului punand parametri pe stiva (intai al doilea, apoi primul), preluand sirul modificat si restaurand stiva.

TASK 1 - functia xor_strings

	Am luat cate un bit din encoded string cu unul din key si le-am facut xor, stocand rezultatul in bit-ul din encoded string. Am incrementat adresele si am repetat operatia pana am ajuns la sfarsit de sir (bit-ul nul).

TASK 2 - functia rolling_xor

	Am folosit hint-ul de la task 1: (x xor k) xor k = x.
	Am plecat de la primul bit din sirul criptat; acesta se transpune nemodificat in sirul decriptat.
	Pentru a decodifica al doilea bit, i-am facut xor cu bit-ul decriptat de dinaintea sa (primul bit).
	Pentru al treilea bit, i-am facut xor cu cei doi biti decriptati de dinaintea sa: cu primul, apoi cu al doilea.
	Tot asa, pentru fiecare bit, i-am facut xor, pe rand, cu bitii decriptati de dinaintea lui.

TASK 3 - functia xor_hex_strings

	Am implementat doua functii auxiliare: 
	-hex_char_to_bin (converteste un caracter hexazecimal in valoarea sa efectiva) si 
	-hex_string_to_bin (ia cate doua caractere hexazecimale odata si formeaza un octet cu ele; le trece prin functia hex_char_to_bin; apoi pe primul il inmulteste cu 16 si la el il aduna pe al doilea).
	In plus, noul sir convertit din hexazecimal va avea o lungime de doua ori mai mica (din 2 caractere fac unul). ebx retine pozitia unde trebuie stocat urmatorul byte nou format. Este negativ pentru ca adresa unde stocam noul byte este mai in stanga decat adresa caracterului hexazecimal unde am ajuns.
	Folosind aceste functii, convertesc encoded string si key, apoi pur si simplu apelez functia xor_strings de la task 1.

TASK 4 - functia base32decode

	Intai, ma deplasez pana la ultimul caracter diferit de '=' sau null (sa stiu unde se termina sirul efectiv). Pornind de aici inapoi, iau cate un caracter si ii calculez valoarea din alfabetul base32 (pentru litere, scad codul ASCII al lui 'A', iar pentru cifrele 2-7, scad 24 din codul lor ASCII: codul ASCII al lui 2 este 50, iar valoarea lui in base32 este 26 => 50 - 24 = 26).

	Shiftez la stanga de 5 ori pentru a lua cate un bit si a-l pune efectiv pe stiva. Fac asta pentru toate caracterele, pana ajung la inceputul sirului. 

	Acum, iau bitii de pe stiva (cate 8 pentru a forma cate un octet din sirul decodat), ei fiind deja in ordine.

	Inainte de a incepe sa pun bitii pe stiva, am pus valoarea 2, pentru a sti cand sa ma opresc atunci cand ii iau de pe stiva.

TASK 5 - functia bruteforce_singlebyte_xor

	ecx este pe post de cheie si ii tot dau valori (0, 1, 2, ...) pana o gasesc pe cea buna.
	Iau cate un octet din encoded string si ii fac xor cu cheia, pana cand caracterul rezultat este 'f'.
	Daca am gasit 'f', caut, la rand, caracterele 'o', 'r', 'c', 'e'; daca nu, continui sa caut 'f'.
	Cand am ajuns la sfarsit de sir, incerc cu o alta cheie.

TASK 6 - functia decode_vigenere

	Iau cate un caracter din encoded string si unul din key si il rotesc (in sens invers fata de codificare). Cand intalnesc un caracter care nu este litera, sar peste el, fara a incrementa cheia. Cand am ajuns la sfarsitul sirului key, o iau iar de pe stiva in ecx.
	Cum fac rotirea: aflu offset-ul fata de 'a' (scad 'a') pentru a vedea cu cate pozitii fac rotirea.
	Daca s-a produs o depasire si caraterul nou format nu mai e litera (s-a dus la stanga lui 'a'), trebuie sa:
	-aflu cu cate pozitii s-a depasit: 'a' - [eax]
	-cu acest numar de pozitii ma deplasez la stanga incepand, de data aceasta, de la 'z': ('z' - ('a' - [eax]) )
	-adaug 1 care se neglijeaza atunci cand facem scaderea din 'z' (deoarece corect ar fi ('z' + 1)- ('a' - [eax]) )
